<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conversation Data Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            padding: 30px;
            background: #f8f9fa;
        }

        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
            transition: transform 0.2s;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #666;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .controls {
            padding: 30px;
            background: white;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        .search-box {
            flex: 1;
            min-width: 250px;
            position: relative;
        }

        .search-box input {
            width: 100%;
            padding: 12px 40px 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .search-box input:focus {
            outline: none;
            border-color: #667eea;
        }

        .filter-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .filter-select {
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .filter-select:focus {
            outline: none;
            border-color: #667eea;
        }

        .table-container {
            overflow-x: auto;
            max-height: 600px;
            overflow-y: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        thead {
            position: sticky;
            top: 0;
            background: #667eea;
            color: white;
            z-index: 10;
        }

        th {
            padding: 15px;
            text-align: left;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.85em;
            letter-spacing: 0.5px;
            cursor: pointer;
            user-select: none;
        }

        th:hover {
            background: #5568d3;
        }

        th.sortable::after {
            content: ' ‚Üï';
            opacity: 0.5;
        }

        th.sort-asc::after {
            content: ' ‚Üë';
            opacity: 1;
        }

        th.sort-desc::after {
            content: ' ‚Üì';
            opacity: 1;
        }

        tbody tr {
            border-bottom: 1px solid #e0e0e0;
            transition: background-color 0.2s;
        }

        tbody tr:hover {
            background-color: #f8f9fa;
        }

        td {
            padding: 12px 15px;
            color: #333;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .badge-success {
            background: #d4edda;
            color: #155724;
        }

        .badge-danger {
            background: #f8d7da;
            color: #721c24;
        }

        .badge-info {
            background: #d1ecf1;
            color: #0c5460;
        }

        .badge-warning {
            background: #fff3cd;
            color: #856404;
        }

        .phrases {
            max-width: 300px;
        }

        .phrases span {
            display: inline-block;
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            margin: 2px;
        }

        .pagination {
            padding: 20px 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            background: #f8f9fa;
        }

        .pagination button {
            padding: 8px 16px;
            border: 1px solid #e0e0e0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pagination button:hover:not(:disabled) {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination-info {
            margin: 0 15px;
            color: #666;
        }

        .loading {
            text-align: center;
            padding: 60px;
            color: #666;
            font-size: 1.2em;
        }

        .empty-state {
            text-align: center;
            padding: 60px;
            color: #999;
        }

        .empty-state svg {
            width: 100px;
            height: 100px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .phrase-stats {
            padding: 30px;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
        }

        .phrase-stats h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .phrase-category {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .phrase-category h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .phrase-count {
            font-size: 2em;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 10px;
        }

        .phrase-list {
            margin-top: 20px;
        }

        .phrase-item {
            background: #f8f9fa;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .phrase-text {
            flex: 1;
            color: #333;
            font-size: 0.95em;
        }

        .phrase-frequency {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
            margin-left: 15px;
        }

        .conversation-ids {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
        }

        .conversation-ids-label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .conversation-id-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .conversation-id {
            background: #e3f2fd;
            color: #1976d2;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.8em;
            font-family: monospace;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .conversation-id:hover {
            background: #bbdefb;
        }

        .no-phrases {
            color: #999;
            font-style: italic;
            padding: 20px;
            text-align: center;
        }

        .entity-view {
            padding: 30px;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
        }

        .entity-view-header {
            margin-bottom: 24px;
        }

        .entity-view h2 {
            color: #1e293b;
            margin-bottom: 8px;
            font-size: 1.875em;
            font-weight: 700;
        }

        .entity-view-subtitle {
            color: #64748b;
            font-size: 0.875em;
            margin-top: 4px;
        }

        .entity-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .entity-stat-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            border: 2px solid #e2e8f0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
        }

        .entity-stat-icon {
            width: 24px;
            height: 24px;
            margin-bottom: auto;
            color: #475569;
        }

        .entity-stat-value {
            font-size: 1.875em;
            font-weight: 700;
            color: #0f172a;
            margin-bottom: 4px;
            margin-top: auto;
        }

        .entity-stat-label {
            font-size: 0.875em;
            font-weight: 500;
            color: #475569;
        }

        .entity-view-controls {
            background: white;
            border-radius: 12px;
            padding: 16px 24px;
            margin-bottom: 24px;
            border: 2px solid #e2e8f0;
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
            align-items: center;
        }

        .entity-view-controls label {
            font-weight: 600;
            color: #334155;
            font-size: 0.875em;
        }

        .entity-view-controls select {
            padding: 8px 12px;
            border: 1px solid #cbd5e1;
            border-radius: 8px;
            font-size: 0.875em;
            background: white;
            cursor: pointer;
            color: #334155;
            transition: all 0.2s;
        }

        .entity-view-controls select:hover {
            border-color: #94a3b8;
        }

        .entity-view-controls select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .entity-list-container {
            background: white;
            border-radius: 12px;
            border: 2px solid #e2e8f0;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .entity-list-header {
            padding: 16px 24px;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }

        .entity-list-title {
            font-size: 1.125em;
            font-weight: 700;
            color: #0f172a;
        }

        .entity-list-count {
            font-size: 0.875em;
            color: #64748b;
            margin-top: 4px;
        }

        .entity-list-content {
            max-height: 700px;
            overflow-y: auto;
        }

        .entity-card {
            padding: 24px;
            border-bottom: 1px solid #f1f5f9;
            transition: background-color 0.2s;
        }

        .entity-card:hover {
            background-color: #f8fafc;
        }

        .entity-card:last-child {
            border-bottom: none;
        }

        .entity-card-header {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            margin-bottom: 16px;
        }

        .entity-icon {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            border: 2px solid;
            font-size: 24px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .entity-icon-contract {
            background: #dbeafe;
            border-color: #bfdbfe;
            color: #2563eb;
        }

        .entity-icon-client {
            background: #f3e8ff;
            border-color: #e9d5ff;
            color: #9333ea;
        }

        .entity-icon-maid {
            background: #fef3c7;
            border-color: #fde68a;
            color: #d97706;
        }

        .entity-main-content {
            flex: 1;
            min-width: 0;
        }

        .entity-title-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
            flex-wrap: wrap;
            gap: 12px;
        }

        .entity-title {
            font-size: 1em;
            font-weight: 700;
            color: #0f172a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        .entity-badges {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .entity-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.75em;
            font-weight: 600;
            border: 1px solid;
        }

        .entity-badge-pro {
            background: #dcfce7;
            color: #166534;
            border-color: #bbf7d0;
        }

        .entity-badge-asking {
            background: #fef3c7;
            color: #92400e;
            border-color: #fde68a;
        }

        .entity-metadata {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }

        .entity-metadata-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.8125em;
            color: #64748b;
        }

        .entity-metadata-label {
            font-weight: 600;
            color: #475569;
        }

        .entity-metadata-value {
            font-family: monospace;
            background: #f1f5f9;
            padding: 2px 8px;
            border-radius: 4px;
            color: #334155;
        }

        .entity-section {
            margin-top: 16px;
        }

        .entity-section-title {
            font-size: 0.75em;
            font-weight: 700;
            color: #475569;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 10px;
        }

        .entity-phrases-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .entity-phrase-item {
            display: flex;
            align-items: start;
            gap: 8px;
            padding: 12px 16px;
            border-left: 2px solid #cbd5e1;
            background: #f8fafc;
            border-radius: 0 8px 8px 0;
            flex: 1;
            min-width: 200px;
        }

        .entity-phrase-quote {
            color: #94a3b8;
            font-size: 1.125em;
            line-height: 1;
        }

        .entity-phrase-text {
            font-size: 0.875em;
            color: #334155;
            font-style: italic;
            line-height: 1.5;
            flex: 1;
        }

        .entity-phrase-count-badge {
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 600;
            flex-shrink: 0;
        }

        .entity-conversations {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #e2e8f0;
        }

        .entity-conversations-label {
            font-size: 0.8125em;
            color: #64748b;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .entity-conversation-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }

        .entity-conversation-id {
            background: #dbeafe;
            color: #1e40af;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 0.75em;
            font-family: monospace;
            cursor: pointer;
            transition: background-color 0.2s;
            border: 1px solid #bfdbfe;
        }

        .entity-conversation-id:hover {
            background: #bfdbfe;
        }

        .entity-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            color: #94a3b8;
        }

        .entity-empty-icon {
            width: 48px;
            height: 48px;
            margin-bottom: 12px;
            opacity: 0.5;
        }

        .entity-empty-text {
            font-weight: 500;
            color: #64748b;
            margin-bottom: 4px;
        }

        .entity-empty-subtext {
            font-size: 0.875em;
            color: #94a3b8;
        }

        .studies-view {
            padding: 30px;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
        }

        .studies-view-header {
            margin-bottom: 24px;
        }

        .studies-view h2 {
            color: #1e293b;
            margin-bottom: 8px;
            font-size: 1.875em;
            font-weight: 700;
        }

        .studies-view-subtitle {
            color: #64748b;
            font-size: 0.875em;
            margin-top: 4px;
        }

        .studies-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .studies-stat-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            border: 2px solid #e2e8f0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
        }

        .studies-stat-value {
            font-size: 1.875em;
            font-weight: 700;
            color: #0f172a;
            margin-bottom: 4px;
        }

        .studies-stat-label {
            font-size: 0.875em;
            font-weight: 500;
            color: #475569;
        }

        .studies-chat-container {
            background: white;
            border-radius: 12px;
            border: 2px solid #e2e8f0;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            margin-bottom: 24px;
        }

        .studies-chat-header {
            padding: 16px 24px;
            border-bottom: 1px solid #e2e8f0;
            background: #f8fafc;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }

        .studies-chat-title {
            font-size: 1.125em;
            font-weight: 700;
            color: #0f172a;
        }

        .studies-chat-meta {
            font-size: 0.875em;
            color: #64748b;
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .studies-chat-content {
            padding: 24px;
            max-height: 500px;
            overflow-y: auto;
        }

        .studies-chat-message {
            margin-bottom: 16px;
            padding: 12px 16px;
            background: #f1f5f9;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .studies-chat-message:last-child {
            margin-bottom: 0;
        }

        .studies-chat-message-text {
            color: #334155;
            font-size: 0.875em;
            line-height: 1.6;
            font-style: italic;
        }

        .studies-loading {
            text-align: center;
            padding: 60px;
            color: #666;
            font-size: 1.2em;
        }

        .studies-empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            color: #94a3b8;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üìä Conversation Data Dashboard</h1>
            <p>Interactive data visualization and analysis</p>
        </div>

        <div class="stats" id="stats">
            <div class="stat-card">
                <div class="stat-value" id="totalUniqueEntities">0</div>
                <div class="stat-label">Total Unique Entities</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="proServicesEntities">0</div>
                <div class="stat-label">Pro Services Entities</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="askingEntities">0</div>
                <div class="stat-label">Asking Entities</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="bothFlagsEntities">0</div>
                <div class="stat-label">Both Flags Entities</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="proServicesWithPhrases">0</div>
                <div class="stat-label">Pro Services with Phrases</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="askingWithPhrases">0</div>
                <div class="stat-label">Asking with Phrases</div>
            </div>
        </div>

        <div class="controls">
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="üîç Search conversations, clients, contracts...">
            </div>
            <div class="filter-group">
                <select class="filter-select" id="statusFilter">
                    <option value="">All Statuses</option>
                    <option value="succeeded">Succeeded</option>
                    <option value="failed">Failed</option>
                </select>
                <select class="filter-select" id="proServicesFilter">
                    <option value="">All Records</option>
                    <option value="true">Pro Services Related</option>
                    <option value="false">Not Pro Services</option>
                </select>
                <select class="filter-select" id="contractTypeFilter">
                    <option value="">All Contract Types</option>
                </select>
                <label style="display: flex; align-items: center; gap: 8px; padding: 12px 15px; border: 2px solid #e0e0e0; border-radius: 8px; background: white; cursor: pointer;">
                    <input type="checkbox" id="useDeduplicatedToggle" checked style="cursor: pointer;">
                    <span style="font-size: 0.9em; color: #666;">Use Deduplicated Data</span>
                </label>
            </div>
            <div style="padding: 15px 30px; background: #fff3cd; border-bottom: 1px solid #e0e0e0; color: #856404;">
                <strong>Note:</strong> Only showing entities with <code>is_pro_services_related = true</code> OR <code>is_asking_if_maids_provides_it = true</code>
            </div>
        </div>

        <div class="table-container">
            <table id="dataTable">
                <thead>
                    <tr>
                        <th class="sortable" data-sort="conversationId">Conversation ID</th>
                        <th class="sortable" data-sort="chatStartDateTime">Date</th>
                        <th class="sortable" data-sort="clientName">Client Name</th>
                        <th class="sortable" data-sort="clientId">Client ID</th>
                        <th class="sortable" data-sort="contractId">Contract ID</th>
                        <th class="sortable" data-sort="contractType">Contract Type</th>
                        <th class="sortable" data-sort="is_pro_services_related">Pro Services</th>
                        <th class="sortable" data-sort="is_asking_if_maids_provides_it">Asking if Maids Provides</th>
                        <th class="sortable" data-sort="matched_phrases">Matched Phrases</th>
                        <th class="sortable" data-sort="processingStatus">Status</th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                    <tr>
                        <td colspan="10" class="loading">Loading data...</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="pagination">
            <button id="prevBtn" onclick="changePage(-1)">‚Üê Previous</button>
            <span class="pagination-info" id="pageInfo">Page 1 of 1</span>
            <button id="nextBtn" onclick="changePage(1)">Next ‚Üí</button>
        </div>

        <div class="phrase-stats" id="phraseStats">
            <h2>üìà Statistics by Category (True Values)</h2>
            <div id="phraseStatsContent">
                <div class="loading">Loading statistics...</div>
            </div>
        </div>

        <div class="entity-view" id="entityView">
            <div class="entity-view-header">
                <h2>üîó Phrases Merged by Entity</h2>
                <div class="entity-view-subtitle">View all phrases grouped by contract, client, or maid</div>
            </div>

            <div id="entityStatsGrid" class="entity-stats-grid">
                <!-- Stats will be populated by JavaScript -->
            </div>

            <div class="entity-view-controls">
                <label>Entity Type:</label>
                <select id="entityTypeFilter">
                    <option value="all">All Entities</option>
                    <option value="contract">Contract</option>
                    <option value="client">Client</option>
                    <option value="maid">Maid</option>
                </select>
                <label>Show Only:</label>
                <select id="entityPhraseFilter">
                    <option value="all">All Entities</option>
                    <option value="with-phrases">Entities with Phrases</option>
                    <option value="pro-services">Pro Services Related</option>
                    <option value="asking">Asking if Maids Provides</option>
                </select>
            </div>

            <div class="entity-list-container">
                <div class="entity-list-header">
                    <div>
                        <div class="entity-list-title">Entities</div>
                        <div class="entity-list-count" id="entityListCount">0 entities</div>
                    </div>
                </div>
                <div class="entity-list-content" id="entityViewContent">
                    <div class="loading">Loading entity view...</div>
                </div>
            </div>
        </div>

        <div class="studies-view" id="studiesView">
            <div class="studies-view-header">
                <h2>üìö Studies Dashboard</h2>
                <div class="studies-view-subtitle">Analytics for flow.csv data - Pro Services Related Cases</div>
            </div>

            <div id="studiesStatsGrid" class="studies-stats-grid">
                <div class="studies-loading">Loading studies data...</div>
            </div>

            <div id="studiesChatsContainer">
                <div class="studies-loading">Loading chat conversations...</div>
            </div>
        </div>
    </div>

    <script src="lib/deduplicate-entities.js"></script>
    <script>
        let allData = [];
        let rawData = [];
        let deduplicatedData = [];
        let filteredData = [];
        let currentPage = 1;
        const itemsPerPage = 50;
        let sortColumn = null;
        let sortDirection = 'asc';
        let useDeduplicated = true; // Toggle to use deduplicated data

        // Load JSON data
        async function loadData() {
            try {
                const response = await fetch('lib/test.json');
                rawData = await response.json();
                
                // Deduplicate data using the script
                if (typeof deduplicateByEntity !== 'undefined') {
                    console.log('[Dashboard] Deduplicating data...');
                    deduplicatedData = deduplicateByEntity(rawData);
                    console.log(`[Dashboard] Deduplication complete: ${rawData.length} ‚Üí ${deduplicatedData.length} records`);
                    allData = useDeduplicated ? deduplicatedData : rawData;
                } else {
                    console.warn('[Dashboard] Deduplication script not loaded, using raw data');
                    allData = rawData;
                }
                
                filteredData = [...allData];
                
                // Populate contract type filter
                const contractTypes = [...new Set(allData.map(item => item.contractType).filter(Boolean))];
                const contractTypeFilter = document.getElementById('contractTypeFilter');
                contractTypes.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    contractTypeFilter.appendChild(option);
                });

                updateStats();
                updatePhraseStats();
                updateEntityView();
                renderTable();
            } catch (error) {
                document.getElementById('tableBody').innerHTML = 
                    '<tr><td colspan="10" class="empty-state">Error loading data. Please ensure lib/test.json exists.</td></tr>';
                console.error('Error loading data:', error);
            }
        }

        function updateStats() {
            // Filter to only entities with pro_services_related = true OR asking_if_maids_provides_it = true
            const relevantData = allData.filter(item => 
                item.is_pro_services_related === true || item.is_asking_if_maids_provides_it === true
            );
            
            // Group by unique entities
            const entityMap = new Map();
            relevantData.forEach(item => {
                // Determine entity key (priority: contractId > clientId > maidId)
                let entityKey = '';
                if (item.contractId) {
                    entityKey = `contract_${item.contractId}`;
                } else if (item.clientId) {
                    entityKey = `client_${item.clientId}`;
                } else if (item.maidId) {
                    entityKey = `maid_${item.maidId}`;
                } else {
                    return; // Skip items without entity identifier
                }
                
                if (!entityMap.has(entityKey)) {
                    entityMap.set(entityKey, {
                        isProServicesRelated: false,
                        isAskingIfMaidsProvides: false,
                        hasPhrases: false
                    });
                }
                
                const entity = entityMap.get(entityKey);
                if (item.is_pro_services_related === true) {
                    entity.isProServicesRelated = true;
                }
                if (item.is_asking_if_maids_provides_it === true) {
                    entity.isAskingIfMaidsProvides = true;
                }
                if (item.matched_phrases && Array.isArray(item.matched_phrases) && item.matched_phrases.length > 0) {
                    entity.hasPhrases = true;
                }
            });
            
            const uniqueEntities = Array.from(entityMap.values());
            const totalUniqueEntities = uniqueEntities.length;
            const proServicesEntities = uniqueEntities.filter(e => e.isProServicesRelated).length;
            const askingEntities = uniqueEntities.filter(e => e.isAskingIfMaidsProvides).length;
            const bothFlagsEntities = uniqueEntities.filter(e => e.isProServicesRelated && e.isAskingIfMaidsProvides).length;
            const proServicesWithPhrases = uniqueEntities.filter(e => e.isProServicesRelated && e.hasPhrases).length;
            const askingWithPhrases = uniqueEntities.filter(e => e.isAskingIfMaidsProvides && e.hasPhrases).length;

            document.getElementById('totalUniqueEntities').textContent = totalUniqueEntities.toLocaleString();
            document.getElementById('proServicesEntities').textContent = proServicesEntities.toLocaleString();
            document.getElementById('askingEntities').textContent = askingEntities.toLocaleString();
            document.getElementById('bothFlagsEntities').textContent = bothFlagsEntities.toLocaleString();
            document.getElementById('proServicesWithPhrases').textContent = proServicesWithPhrases.toLocaleString();
            document.getElementById('askingWithPhrases').textContent = askingWithPhrases.toLocaleString();
        }

        function updatePhraseStats() {
            // Get records where is_pro_services_related is true
            const proServicesTrue = allData.filter(item => item.is_pro_services_related === true);
            
            // Get records where is_asking_if_maids_provides_it is true
            const askingTrue = allData.filter(item => item.is_asking_if_maids_provides_it === true);

            // Group phrases by entity (contract > client > maid) for pro_services_related = true
            const proServicesByEntity = new Map();
            proServicesTrue.forEach(item => {
                // Determine entity key (priority: contractId > clientId > maidId)
                let entityKey = '';
                if (item.contractId) {
                    entityKey = `contract_${item.contractId}`;
                } else if (item.clientId) {
                    entityKey = `client_${item.clientId}`;
                } else if (item.maidId) {
                    entityKey = `maid_${item.maidId}`;
                } else {
                    return; // Skip items without entity identifier
                }
                
                // Handle merged conversation IDs from deduplication
                const convIds = item.mergedConversationIds || 
                               (item.conversationId ? item.conversationId.split(',').map(id => id.trim()).filter(Boolean) : []);
                
                if (!proServicesByEntity.has(entityKey)) {
                    proServicesByEntity.set(entityKey, {
                        entityKey,
                        entityType: item.contractId ? 'contract' : item.clientId ? 'client' : 'maid',
                        entityId: item.contractId || item.clientId || item.maidId,
                        entityName: item.clientName || item.maidName || 'Unknown',
                        contractId: item.contractId || '',
                        clientId: item.clientId || '',
                        maidId: item.maidId || '',
                        contractType: item.contractType || '',
                        conversationIds: new Set(),
                        phrases: []
                    });
                }
                
                const entityData = proServicesByEntity.get(entityKey);
                convIds.forEach(id => entityData.conversationIds.add(id));
                
                // Add all phrases from this record
                if (item.matched_phrases && Array.isArray(item.matched_phrases)) {
                    item.matched_phrases.forEach(phrase => {
                        if (phrase && phrase.trim()) {
                            const trimmedPhrase = phrase.trim();
                            if (!entityData.phrases.includes(trimmedPhrase)) {
                                entityData.phrases.push(trimmedPhrase);
                            }
                        }
                    });
                }
            });

            // Group phrases by entity (contract > client > maid) for is_asking_if_maids_provides_it = true
            const askingByEntity = new Map();
            askingTrue.forEach(item => {
                // Determine entity key (priority: contractId > clientId > maidId)
                let entityKey = '';
                if (item.contractId) {
                    entityKey = `contract_${item.contractId}`;
                } else if (item.clientId) {
                    entityKey = `client_${item.clientId}`;
                } else if (item.maidId) {
                    entityKey = `maid_${item.maidId}`;
                } else {
                    return; // Skip items without entity identifier
                }
                
                // Handle merged conversation IDs from deduplication
                const convIds = item.mergedConversationIds || 
                               (item.conversationId ? item.conversationId.split(',').map(id => id.trim()).filter(Boolean) : []);
                
                if (!askingByEntity.has(entityKey)) {
                    askingByEntity.set(entityKey, {
                        entityKey,
                        entityType: item.contractId ? 'contract' : item.clientId ? 'client' : 'maid',
                        entityId: item.contractId || item.clientId || item.maidId,
                        entityName: item.clientName || item.maidName || 'Unknown',
                        contractId: item.contractId || '',
                        clientId: item.clientId || '',
                        maidId: item.maidId || '',
                        contractType: item.contractType || '',
                        conversationIds: new Set(),
                        phrases: []
                    });
                }
                
                const entityData = askingByEntity.get(entityKey);
                convIds.forEach(id => entityData.conversationIds.add(id));
                
                // Add all phrases from this record
                if (item.matched_phrases && Array.isArray(item.matched_phrases)) {
                    item.matched_phrases.forEach(phrase => {
                        if (phrase && phrase.trim()) {
                            const trimmedPhrase = phrase.trim();
                            if (!entityData.phrases.includes(trimmedPhrase)) {
                                entityData.phrases.push(trimmedPhrase);
                            }
                        }
                    });
                }
            });

            // Convert to arrays and sort by number of phrases (descending)
            const sortedProServicesEntities = Array.from(proServicesByEntity.values())
                .map(entity => ({
                    ...entity,
                    conversationIds: Array.from(entity.conversationIds)
                }))
                .sort((a, b) => b.phrases.length - a.phrases.length);
            
            const sortedAskingEntities = Array.from(askingByEntity.values())
                .map(entity => ({
                    ...entity,
                    conversationIds: Array.from(entity.conversationIds)
                }))
                .sort((a, b) => b.phrases.length - a.phrases.length);

            // Render the statistics
            const statsContent = document.getElementById('phraseStatsContent');
            let html = '';

            // Pro Services Related = true
            html += `
                <div class="phrase-category">
                    <h3>‚úÖ is_pro_services_related = true</h3>
                    <div class="phrase-count">${proServicesTrue.length.toLocaleString()} records</div>
                    <div>Unique entities: ${sortedProServicesEntities.length}</div>
                    <div>Total unique phrases: ${sortedProServicesEntities.reduce((sum, e) => sum + e.phrases.length, 0)}</div>
                    <div class="phrase-list">
            `;
            
            if (sortedProServicesEntities.length > 0) {
                sortedProServicesEntities.forEach((entityData) => {
                    if (entityData.phrases.length === 0) return;
                    
                    const entityLabel = entityData.entityType === 'contract'
                        ? `üìÑ Contract ${entityData.contractId}${entityData.entityName !== 'Unknown' ? ` ‚Ä¢ ${escapeHtml(entityData.entityName)}` : ''}`
                        : entityData.entityType === 'client'
                        ? `üë§ Client ${entityData.clientId}${entityData.entityName !== 'Unknown' ? ` ‚Ä¢ ${escapeHtml(entityData.entityName)}` : ''}`
                        : `üßπ Maid ${entityData.maidId}${entityData.entityName !== 'Unknown' ? ` ‚Ä¢ ${escapeHtml(entityData.entityName)}` : ''}`;
                    
                    html += `
                        <div class="phrase-item">
                            <div style="flex: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                    <div style="font-weight: 600; color: #667eea; font-size: 0.95em;">
                                        ${entityLabel}
                                    </div>
                                    <div style="font-size: 0.85em; color: #666;">
                                        ${entityData.phrases.length} ${entityData.phrases.length === 1 ? 'phrase' : 'phrases'} ‚Ä¢ ${entityData.conversationIds.length} ${entityData.conversationIds.length === 1 ? 'conversation' : 'conversations'}
                                    </div>
                                </div>
                                ${entityData.contractType ? `
                                    <div style="margin-bottom: 8px;">
                                        <span class="badge badge-info">${escapeHtml(entityData.contractType)}</span>
                                    </div>
                                ` : ''}
                                <div style="margin-bottom: 12px;">
                                    ${entityData.phrases.map(phrase => `
                                        <div style="padding: 8px 12px; margin-bottom: 6px; background: #f8f9fa; border-left: 3px solid #667eea; border-radius: 4px;">
                                            <div class="phrase-text" style="font-style: italic; color: #333;">${escapeHtml(phrase)}</div>
                                        </div>
                                    `).join('')}
                                </div>
                                <div class="conversation-ids">
                                    <div class="conversation-ids-label">Conversation IDs (${entityData.conversationIds.length}):</div>
                                    <div class="conversation-id-list">
                    `;
                    entityData.conversationIds.forEach(convId => {
                        const escapedId = escapeJsString(convId);
                        html += `<span class="conversation-id" onclick="filterByConversationId('${escapedId}')" title="Click to filter table">${escapeHtml(convId)}</span>`;
                    });
                    html += `
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });
            } else {
                html += '<div class="no-phrases">No phrases found in these records</div>';
            }
            
            html += '</div></div>';

            // is_asking_if_maids_provides_it = true
            html += `
                <div class="phrase-category">
                    <h3>‚ùì is_asking_if_maids_provides_it = true</h3>
                    <div class="phrase-count">${askingTrue.length.toLocaleString()} records</div>
                    <div>Unique entities: ${sortedAskingEntities.length}</div>
                    <div>Total unique phrases: ${sortedAskingEntities.reduce((sum, e) => sum + e.phrases.length, 0)}</div>
                    <div class="phrase-list">
            `;
            
            if (sortedAskingEntities.length > 0) {
                sortedAskingEntities.forEach((entityData) => {
                    if (entityData.phrases.length === 0) return;
                    
                    const entityLabel = entityData.entityType === 'contract'
                        ? `üìÑ Contract ${entityData.contractId}${entityData.entityName !== 'Unknown' ? ` ‚Ä¢ ${escapeHtml(entityData.entityName)}` : ''}`
                        : entityData.entityType === 'client'
                        ? `üë§ Client ${entityData.clientId}${entityData.entityName !== 'Unknown' ? ` ‚Ä¢ ${escapeHtml(entityData.entityName)}` : ''}`
                        : `üßπ Maid ${entityData.maidId}${entityData.entityName !== 'Unknown' ? ` ‚Ä¢ ${escapeHtml(entityData.entityName)}` : ''}`;
                    
                    html += `
                        <div class="phrase-item">
                            <div style="flex: 1;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                                    <div style="font-weight: 600; color: #667eea; font-size: 0.95em;">
                                        ${entityLabel}
                                    </div>
                                    <div style="font-size: 0.85em; color: #666;">
                                        ${entityData.phrases.length} ${entityData.phrases.length === 1 ? 'phrase' : 'phrases'} ‚Ä¢ ${entityData.conversationIds.length} ${entityData.conversationIds.length === 1 ? 'conversation' : 'conversations'}
                                    </div>
                                </div>
                                ${entityData.contractType ? `
                                    <div style="margin-bottom: 8px;">
                                        <span class="badge badge-info">${escapeHtml(entityData.contractType)}</span>
                                    </div>
                                ` : ''}
                                <div style="margin-bottom: 12px;">
                                    ${entityData.phrases.map(phrase => `
                                        <div style="padding: 8px 12px; margin-bottom: 6px; background: #f8f9fa; border-left: 3px solid #667eea; border-radius: 4px;">
                                            <div class="phrase-text" style="font-style: italic; color: #333;">${escapeHtml(phrase)}</div>
                                        </div>
                                    `).join('')}
                                </div>
                                <div class="conversation-ids">
                                    <div class="conversation-ids-label">Conversation IDs (${entityData.conversationIds.length}):</div>
                                    <div class="conversation-id-list">
                    `;
                    entityData.conversationIds.forEach(convId => {
                        const escapedId = escapeJsString(convId);
                        html += `<span class="conversation-id" onclick="filterByConversationId('${escapedId}')" title="Click to filter table">${escapeHtml(convId)}</span>`;
                    });
                    html += `
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                });
            } else {
                html += '<div class="no-phrases">No phrases found in these records</div>';
            }
            
            html += '</div></div>';

            statsContent.innerHTML = html;
        }

        function filterByConversationId(convId) {
            document.getElementById('searchInput').value = convId;
            filterData();
            // Scroll to table
            document.querySelector('.table-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function updateEntityView() {
            const entityTypeFilter = document.getElementById('entityTypeFilter').value;
            const phraseFilter = document.getElementById('entityPhraseFilter').value;
            
            // Use deduplicated data if available, otherwise process raw data
            const dataToProcess = useDeduplicated && deduplicatedData.length > 0 ? deduplicatedData : allData;
            
            // First filter: only show entities with pro_services_related = true OR asking_if_maids_provides_it = true
            const relevantData = dataToProcess.filter(item => 
                item.is_pro_services_related === true || item.is_asking_if_maids_provides_it === true
            );
            
            // Step 1: Group all records by entity first (before deduplication)
            const entityRecordsMap = new Map(); // entityKey -> array of records
            
            relevantData.forEach(item => {
                // Determine entity key (priority: contractId > clientId > maidId)
                let entityKey = '';
                let entityType = '';
                
                if (item.contractId) {
                    entityKey = `contract_${item.contractId}`;
                    entityType = 'contract';
                } else if (item.clientId) {
                    entityKey = `client_${item.clientId}`;
                    entityType = 'client';
                } else if (item.maidId) {
                    entityKey = `maid_${item.maidId}`;
                    entityType = 'maid';
                } else {
                    // Skip items without any entity identifier
                    return;
                }
                
                // Filter by entity type
                if (entityTypeFilter !== 'all' && entityType !== entityTypeFilter) {
                    return;
                }
                
                if (!entityRecordsMap.has(entityKey)) {
                    entityRecordsMap.set(entityKey, []);
                }
                entityRecordsMap.get(entityKey).push(item);
            });
            
            // Step 2: For each entity, deduplicate conversations and create initial entity objects
            const initialEntityMap = new Map();
            const conversationIdToEntityKey = new Map(); // conversationId -> entityKey
            
            entityRecordsMap.forEach((records, entityKey) => {
                // Deduplicate conversations within this entity
                const deduplicatedConversations = new Map();
                
                records.forEach(item => {
                    // Handle merged conversation IDs (from deduplication script)
                    const convIds = item.mergedConversationIds || [item.conversationId];
                    
                    // For each conversation ID, check if we've seen it
                    convIds.forEach(convId => {
                        if (!convId) return;
                        
                        const existing = deduplicatedConversations.get(convId);
                        
                        if (!existing) {
                            deduplicatedConversations.set(convId, item);
                        } else {
                            // Keep the one with more data (phrases)
                            const existingPhraseCount = (existing.matched_phrases?.length || 0);
                            const currentPhraseCount = (item.matched_phrases?.length || 0);
                            
                            if (currentPhraseCount > existingPhraseCount) {
                                deduplicatedConversations.set(convId, item);
                            } else if (currentPhraseCount === existingPhraseCount) {
                                // If data is equal, keep the one with both flags set if available
                                const existingBothFlags = existing.is_pro_services_related === true && 
                                                          existing.is_asking_if_maids_provides_it === true;
                                const currentBothFlags = item.is_pro_services_related === true && 
                                                        item.is_asking_if_maids_provides_it === true;
                                if (currentBothFlags && !existingBothFlags) {
                                    deduplicatedConversations.set(convId, item);
                                }
                            }
                        }
                    });
                });
                
                // Now aggregate the deduplicated records for this entity
                const deduplicatedArray = Array.from(deduplicatedConversations.values());
                if (deduplicatedArray.length === 0) return;
                
                const firstRecord = deduplicatedArray[0];
                let entityType = '';
                let entityName = '';
                let entityId = '';
                
                if (firstRecord.contractId) {
                    entityType = 'contract';
                    entityName = firstRecord.clientName || 'Unknown Client';
                    entityId = firstRecord.contractId;
                } else if (firstRecord.clientId) {
                    entityType = 'client';
                    entityName = firstRecord.clientName || 'Unknown Client';
                    entityId = firstRecord.clientId;
                } else if (firstRecord.maidId) {
                    entityType = 'maid';
                    entityName = firstRecord.maidName || 'Unknown Maid';
                    entityId = firstRecord.maidId;
                }
                
                const entity = {
                    entityKey,
                    entityType,
                    entityName,
                    entityId,
                    contractId: firstRecord.contractId || '',
                    clientId: firstRecord.clientId || '',
                    maidId: firstRecord.maidId || '',
                    contractType: firstRecord.contractType || '',
                    conversationIds: new Set(),
                    phrases: new Map(), // phrase -> count
                    isProServicesRelated: false,
                    isAskingIfMaidsProvides: false,
                    totalRecords: deduplicatedArray.length,
                    originalRecords: records.length // Track original count before deduplication
                };
                
                // Aggregate from deduplicated records
                deduplicatedArray.forEach(item => {
                    // Handle merged conversation IDs (from deduplication script)
                    const convIds = item.mergedConversationIds || [item.conversationId];
                    convIds.forEach(convId => {
                        if (convId) entity.conversationIds.add(convId);
                    });
                    
                    // Track flags (if any record has it, mark as true)
                    if (item.is_pro_services_related === true) {
                        entity.isProServicesRelated = true;
                    }
                    if (item.is_asking_if_maids_provides_it === true) {
                        entity.isAskingIfMaidsProvides = true;
                    }
                    
                    // Collect phrases
                    if (item.matched_phrases && Array.isArray(item.matched_phrases)) {
                        item.matched_phrases.forEach(phrase => {
                            if (phrase && phrase.trim()) {
                                const trimmedPhrase = phrase.trim();
                                entity.phrases.set(trimmedPhrase, (entity.phrases.get(trimmedPhrase) || 0) + 1);
                            }
                        });
                    }
                });
                
                initialEntityMap.set(entityKey, entity);
                
                // Index conversation IDs for merging
                entity.conversationIds.forEach(convId => {
                    conversationIdToEntityKey.set(convId, entityKey);
                });
            });
            
            // Step 3: Merge entities that share conversation IDs
            const entityMap = new Map();
            const processedEntityKeys = new Set();
            
            initialEntityMap.forEach((entity, entityKey) => {
                if (processedEntityKeys.has(entityKey)) {
                    return; // Already merged
                }
                
                // Find all entities that share conversation IDs with this one
                const entitiesToMerge = [entity];
                const conversationIdsToCheck = Array.from(entity.conversationIds);
                const mergedEntityKeys = new Set([entityKey]);
                
                // Recursively find all connected entities
                let foundNew = true;
                while (foundNew) {
                    foundNew = false;
                    const newConversationIds = [];
                    
                    conversationIdsToCheck.forEach(convId => {
                        // Check if this conversation ID appears in other entities
                        initialEntityMap.forEach((otherEntity, otherKey) => {
                            if (mergedEntityKeys.has(otherKey)) return;
                            
                            if (otherEntity.conversationIds.has(convId)) {
                                entitiesToMerge.push(otherEntity);
                                mergedEntityKeys.add(otherKey);
                                processedEntityKeys.add(otherKey);
                                foundNew = true;
                                
                                // Add all conversation IDs from this entity to check
                                otherEntity.conversationIds.forEach(otherConvId => {
                                    if (!conversationIdsToCheck.includes(otherConvId)) {
                                        newConversationIds.push(otherConvId);
                                    }
                                });
                            }
                        });
                    });
                    
                    conversationIdsToCheck.push(...newConversationIds);
                }
                
                // Merge all connected entities
                const mergedEntity = {
                    entityKey: entityKey, // Use the first entity's key
                    entityType: entity.entityType,
                    entityName: entity.entityName,
                    entityId: entity.entityId,
                    contractId: entity.contractId,
                    clientId: entity.clientId,
                    maidId: entity.maidId,
                    contractType: entity.contractType,
                    conversationIds: new Set(),
                    phrases: new Map(),
                    isProServicesRelated: false,
                    isAskingIfMaidsProvides: false,
                    totalRecords: 0,
                    originalRecords: 0
                };
                
                // Merge all entities
                entitiesToMerge.forEach(e => {
                    // Merge conversation IDs
                    e.conversationIds.forEach(convId => mergedEntity.conversationIds.add(convId));
                    
                    // Merge phrases
                    e.phrases.forEach((count, phrase) => {
                        mergedEntity.phrases.set(phrase, (mergedEntity.phrases.get(phrase) || 0) + count);
                    });
                    
                    // Merge flags
                    if (e.isProServicesRelated) mergedEntity.isProServicesRelated = true;
                    if (e.isAskingIfMaidsProvides) mergedEntity.isAskingIfMaidsProvides = true;
                    
                    // Merge record counts
                    mergedEntity.totalRecords += e.totalRecords;
                    mergedEntity.originalRecords += e.originalRecords;
                    
                    // Prefer contract > client > maid for entity info
                    if (!mergedEntity.contractId && e.contractId) {
                        mergedEntity.contractId = e.contractId;
                        mergedEntity.entityId = e.contractId;
                        mergedEntity.entityType = 'contract';
                        mergedEntity.entityName = e.entityName;
                        mergedEntity.contractType = e.contractType;
                    } else if (!mergedEntity.clientId && e.clientId && mergedEntity.entityType !== 'contract') {
                        mergedEntity.clientId = e.clientId;
                        mergedEntity.entityId = e.clientId;
                        mergedEntity.entityType = 'client';
                        mergedEntity.entityName = e.entityName;
                    } else if (!mergedEntity.maidId && e.maidId && mergedEntity.entityType !== 'contract' && mergedEntity.entityType !== 'client') {
                        mergedEntity.maidId = e.maidId;
                        mergedEntity.entityId = e.maidId;
                        mergedEntity.entityType = 'maid';
                        mergedEntity.entityName = e.entityName;
                    }
                });
                
                entityMap.set(entityKey, mergedEntity);
                processedEntityKeys.add(entityKey);
            });
            
            // Convert to array and filter
            let entities = Array.from(entityMap.values()).map(entity => ({
                ...entity,
                conversationIds: Array.from(entity.conversationIds),
                phrases: Array.from(entity.phrases.entries()).map(([phrase, count]) => ({ phrase, count }))
            }));
            
            // Calculate stats before filtering
            const totalEntities = entities.length;
            const entitiesWithPhrases = entities.filter(e => e.phrases.length > 0).length;
            const proServicesEntities = entities.filter(e => e.isProServicesRelated === true).length;
            const askingEntities = entities.filter(e => e.isAskingIfMaidsProvides === true).length;
            const totalPhrases = entities.reduce((sum, e) => sum + e.phrases.reduce((s, p) => s + p.count, 0), 0);
            const totalUniqueConversations = entities.reduce((sum, e) => sum + e.conversationIds.size, 0);
            const totalOriginalRecords = entities.reduce((sum, e) => sum + (e.originalRecords || e.totalRecords), 0);
            const totalDeduplicatedRecords = entities.reduce((sum, e) => sum + e.totalRecords, 0);
            const deduplicationSavings = totalOriginalRecords - totalDeduplicatedRecords;
            
            // Update stats grid
            const statsGrid = document.getElementById('entityStatsGrid');
            statsGrid.innerHTML = `
                <div class="entity-stat-card">
                    <div class="entity-stat-icon">üìä</div>
                    <div class="entity-stat-value">${totalEntities.toLocaleString()}</div>
                    <div class="entity-stat-label">Total Entities</div>
                </div>
                <div class="entity-stat-card">
                    <div class="entity-stat-icon">üí¨</div>
                    <div class="entity-stat-value">${totalPhrases.toLocaleString()}</div>
                    <div class="entity-stat-label">Total Phrases</div>
                </div>
                <div class="entity-stat-card">
                    <div class="entity-stat-icon">üìù</div>
                    <div class="entity-stat-value">${totalUniqueConversations.toLocaleString()}</div>
                    <div class="entity-stat-label">Unique Conversations</div>
                </div>
                <div class="entity-stat-card">
                    <div class="entity-stat-icon">‚úÖ</div>
                    <div class="entity-stat-value">${entitiesWithPhrases.toLocaleString()}</div>
                    <div class="entity-stat-label">With Phrases</div>
                </div>
                <div class="entity-stat-card">
                    <div class="entity-stat-icon">üîß</div>
                    <div class="entity-stat-value">${proServicesEntities.toLocaleString()}</div>
                    <div class="entity-stat-label">Pro Services</div>
                </div>
                ${deduplicationSavings > 0 ? `
                <div class="entity-stat-card">
                    <div class="entity-stat-icon">üîÑ</div>
                    <div class="entity-stat-value">${deduplicationSavings.toLocaleString()}</div>
                    <div class="entity-stat-label">Deduplicated</div>
                    <div style="font-size: 0.75em; color: #64748b; margin-top: 4px;">
                        ${totalOriginalRecords.toLocaleString()} ‚Üí ${totalDeduplicatedRecords.toLocaleString()}
                    </div>
                </div>
                ` : ''}
            `;
            
            // Apply phrase filter
            if (phraseFilter === 'with-phrases') {
                entities = entities.filter(e => e.phrases.length > 0);
            } else if (phraseFilter === 'pro-services') {
                entities = entities.filter(e => e.isProServicesRelated === true);
            } else if (phraseFilter === 'asking') {
                entities = entities.filter(e => e.isAskingIfMaidsProvides === true);
            }
            
            // Sort by total phrases count (descending), then by entity name
            entities.sort((a, b) => {
                const aPhraseCount = a.phrases.reduce((sum, p) => sum + p.count, 0);
                const bPhraseCount = b.phrases.reduce((sum, p) => sum + p.count, 0);
                if (bPhraseCount !== aPhraseCount) {
                    return bPhraseCount - aPhraseCount;
                }
                return a.entityName.localeCompare(b.entityName);
            });
            
            // Update count
            document.getElementById('entityListCount').textContent = `${entities.length} ${entities.length === 1 ? 'entity' : 'entities'}`;
            
            // Render entities
            const content = document.getElementById('entityViewContent');
            
            if (entities.length === 0) {
                content.innerHTML = `
                    <div class="entity-empty-state">
                        <div class="entity-empty-icon">üì≠</div>
                        <div class="entity-empty-text">No entities found</div>
                        <div class="entity-empty-subtext">Try adjusting your filters</div>
                    </div>
                `;
                return;
            }
            
            let html = '';
            entities.forEach(entity => {
                const totalPhraseCount = entity.phrases.reduce((sum, p) => sum + p.count, 0);
                const uniquePhraseCount = entity.phrases.length;
                
                // Sort phrases by count (descending)
                const sortedPhrases = [...entity.phrases].sort((a, b) => b.count - a.count);
                
                // Determine icon class
                const iconClass = entity.entityType === 'contract' ? 'entity-icon-contract' : 
                                entity.entityType === 'client' ? 'entity-icon-client' : 'entity-icon-maid';
                const iconEmoji = entity.entityType === 'contract' ? 'üìÑ' : 
                                 entity.entityType === 'client' ? 'üë§' : 'üßπ';
                
                html += `
                    <div class="entity-card">
                        <div class="entity-card-header">
                            <div class="entity-icon ${iconClass}">${iconEmoji}</div>
                            <div class="entity-main-content">
                                <div class="entity-title-row">
                                    <div class="entity-title">${escapeHtml(entity.entityName)}</div>
                                    <div class="entity-badges">
                                        ${entity.isProServicesRelated ? '<span class="entity-badge entity-badge-pro">Pro Services</span>' : ''}
                                        ${entity.isAskingIfMaidsProvides ? '<span class="entity-badge entity-badge-asking">Asking</span>' : ''}
                                    </div>
                                </div>
                                <div class="entity-metadata">
                                    <div class="entity-metadata-item">
                                        <span class="entity-metadata-label">Type:</span>
                                        <span class="entity-metadata-value">${entity.entityType.charAt(0).toUpperCase() + entity.entityType.slice(1)}</span>
                                    </div>
                                    ${entity.contractId ? `
                                        <div class="entity-metadata-item">
                                            <span class="entity-metadata-label">Contract:</span>
                                            <span class="entity-metadata-value">${escapeHtml(entity.contractId)}</span>
                                        </div>
                                    ` : ''}
                                    ${entity.clientId ? `
                                        <div class="entity-metadata-item">
                                            <span class="entity-metadata-label">Client:</span>
                                            <span class="entity-metadata-value">${escapeHtml(entity.clientId)}</span>
                                        </div>
                                    ` : ''}
                                    ${entity.maidId ? `
                                        <div class="entity-metadata-item">
                                            <span class="entity-metadata-label">Maid:</span>
                                            <span class="entity-metadata-value">${escapeHtml(entity.maidId)}</span>
                                        </div>
                                    ` : ''}
                                    ${entity.contractType ? `
                                        <div class="entity-metadata-item">
                                            <span class="entity-metadata-label">Contract Type:</span>
                                            <span class="entity-metadata-value">${escapeHtml(entity.contractType)}</span>
                                        </div>
                                    ` : ''}
                                    <div class="entity-metadata-item">
                                        <span class="entity-metadata-label">Records:</span>
                                        <span class="entity-metadata-value">
                                            ${entity.totalRecords}
                                            ${entity.originalRecords && entity.originalRecords > entity.totalRecords 
                                                ? ` <span style="color: #64748b; font-size: 0.9em;">(${entity.originalRecords} original)</span>` 
                                                : ''}
                                        </span>
                                    </div>
                                    <div class="entity-metadata-item">
                                        <span class="entity-metadata-label">Conversations:</span>
                                        <span class="entity-metadata-value">${entity.conversationIds.length}</span>
                                    </div>
                                </div>
                                
                                ${sortedPhrases.length > 0 ? `
                                    <div class="entity-section">
                                        <div class="entity-section-title">Matched Phrases (${uniquePhraseCount} unique, ${totalPhraseCount} total)</div>
                                        <div class="entity-phrases-list">
                                            ${sortedPhrases.map(p => {
                                                const escapedPhrase = escapeJsString(p.phrase);
                                                return `
                                                    <div class="entity-phrase-item" onclick="filterByPhrase('${escapedPhrase}')" style="cursor: pointer;" title="Click to filter table by this phrase">
                                                        <span class="entity-phrase-quote">"</span>
                                                        <span class="entity-phrase-text">${escapeHtml(p.phrase)}</span>
                                                        <span class="entity-phrase-quote">"</span>
                                                        <span class="entity-phrase-count-badge">${p.count}</span>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    </div>
                                ` : ''}
                                
                                ${entity.conversationIds.length > 0 ? `
                                    <div class="entity-conversations">
                                        <div class="entity-conversations-label">Conversation IDs (${entity.conversationIds.length}):</div>
                                        <div class="entity-conversation-list">
                                            ${entity.conversationIds.slice(0, 15).map(convId => {
                                                const escapedId = escapeJsString(convId);
                                                return `<span class="entity-conversation-id" onclick="filterByConversationId('${escapedId}')" title="Click to filter table">${escapeHtml(convId)}</span>`;
                                            }).join('')}
                                            ${entity.conversationIds.length > 15 ? `<span style="color: #94a3b8; font-size: 0.75em; padding: 4px 10px;">... and ${entity.conversationIds.length - 15} more</span>` : ''}
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            });
            
            content.innerHTML = html;
        }

        function filterByPhrase(phrase) {
            document.getElementById('searchInput').value = phrase;
            filterData();
            // Scroll to table
            document.querySelector('.table-container').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function filterData() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const statusFilter = document.getElementById('statusFilter').value;
            const proServicesFilter = document.getElementById('proServicesFilter').value;
            const contractTypeFilter = document.getElementById('contractTypeFilter').value;

            // First filter: only show entities with pro_services_related = true OR asking_if_maids_provides_it = true
            let baseFiltered = allData.filter(item => 
                item.is_pro_services_related === true || item.is_asking_if_maids_provides_it === true
            );

            filteredData = baseFiltered.filter(item => {
                const matchesSearch = !searchTerm || 
                    item.conversationId?.toLowerCase().includes(searchTerm) ||
                    item.clientName?.toLowerCase().includes(searchTerm) ||
                    item.clientId?.toString().includes(searchTerm) ||
                    item.contractId?.toString().includes(searchTerm) ||
                    item.maidName?.toLowerCase().includes(searchTerm) ||
                    (item.matched_phrases && Array.isArray(item.matched_phrases) && 
                     item.matched_phrases.some(phrase => phrase?.toLowerCase().includes(searchTerm)));

                const matchesStatus = !statusFilter || item.processingStatus === statusFilter;
                const matchesProServices = !proServicesFilter || 
                    item.is_pro_services_related.toString() === proServicesFilter;
                const matchesContractType = !contractTypeFilter || item.contractType === contractTypeFilter;

                return matchesSearch && matchesStatus && matchesProServices && matchesContractType;
            });

            currentPage = 1;
            renderTable();
        }

        function sortData(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }

            filteredData.sort((a, b) => {
                let aVal = a[column];
                let bVal = b[column];

                // Handle arrays (matched_phrases)
                if (Array.isArray(aVal)) {
                    aVal = aVal.length;
                    bVal = bVal.length;
                }

                // Handle dates
                if (column === 'chatStartDateTime' || column === 'processedAt') {
                    aVal = new Date(aVal);
                    bVal = new Date(bVal);
                }

                // Handle booleans
                if (typeof aVal === 'boolean') {
                    aVal = aVal ? 1 : 0;
                    bVal = bVal ? 1 : 0;
                }

                // Handle null/undefined
                if (aVal == null) aVal = '';
                if (bVal == null) bVal = '';

                if (sortDirection === 'asc') {
                    return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                } else {
                    return aVal < bVal ? 1 : aVal > bVal ? -1 : 0;
                }
            });

            // Update sort indicators
            document.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                if (th.dataset.sort === column) {
                    th.classList.add(sortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            });

            renderTable();
        }

        function renderTable() {
            const tbody = document.getElementById('tableBody');
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageData = filteredData.slice(startIndex, endIndex);

            if (pageData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="10" class="empty-state">No data found matching your filters.</td></tr>';
                updatePagination();
                return;
            }

            tbody.innerHTML = pageData.map(item => {
                const date = item.chatStartDateTime ? new Date(item.chatStartDateTime).toLocaleDateString() : '-';
                const proServicesBadge = item.is_pro_services_related 
                    ? '<span class="badge badge-success">Yes</span>' 
                    : '<span class="badge badge-danger">No</span>';
                const askingBadge = item.is_asking_if_maids_provides_it 
                    ? '<span class="badge badge-success">Yes</span>' 
                    : '<span class="badge badge-danger">No</span>';
                const statusBadge = item.processingStatus === 'succeeded'
                    ? '<span class="badge badge-success">Succeeded</span>'
                    : '<span class="badge badge-danger">Failed</span>';
                
                const phrases = item.matched_phrases && item.matched_phrases.length > 0
                    ? item.matched_phrases.map(p => `<span>${escapeHtml(p)}</span>`).join('')
                    : '<span style="color: #999;">None</span>';

                // Handle merged conversation IDs
                const conversationIdDisplay = item.mergedConversationIds && item.mergedConversationIds.length > 1
                    ? `${escapeHtml(item.conversationId)} <span style="color: #667eea; font-size: 0.85em;" title="Merged: ${item.mergedConversationIds.join(', ')}">(${item.mergedConversationIds.length})</span>`
                    : escapeHtml(item.conversationId || '-');

                return `
                    <tr>
                        <td>${conversationIdDisplay}</td>
                        <td>${date}</td>
                        <td>${escapeHtml(item.clientName || '-')}</td>
                        <td>${escapeHtml(item.clientId || '-')}</td>
                        <td>${escapeHtml(item.contractId || '-')}</td>
                        <td><span class="badge badge-info">${escapeHtml(item.contractType || '-')}</span></td>
                        <td>${proServicesBadge}</td>
                        <td>${askingBadge}</td>
                        <td class="phrases">${phrases}</td>
                        <td>${statusBadge}</td>
                    </tr>
                `;
            }).join('');

            updatePagination();
        }

        function updatePagination() {
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            document.getElementById('pageInfo').textContent = 
                `Page ${currentPage} of ${totalPages} (${filteredData.length.toLocaleString()} records)`;
            
            document.getElementById('prevBtn').disabled = currentPage === 1;
            document.getElementById('nextBtn').disabled = currentPage === totalPages || totalPages === 0;
        }

        function changePage(direction) {
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            const newPage = currentPage + direction;
            
            if (newPage >= 1 && newPage <= totalPages) {
                currentPage = newPage;
                renderTable();
                document.querySelector('.table-container').scrollTop = 0;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function escapeJsString(str) {
            return str.replace(/\\/g, '\\\\')
                     .replace(/'/g, "\\'")
                     .replace(/"/g, '\\"')
                     .replace(/\n/g, '\\n')
                     .replace(/\r/g, '\\r');
        }

        // Event listeners
        document.getElementById('searchInput').addEventListener('input', filterData);
        document.getElementById('statusFilter').addEventListener('change', filterData);
        document.getElementById('proServicesFilter').addEventListener('change', filterData);
        document.getElementById('contractTypeFilter').addEventListener('change', filterData);
        document.getElementById('entityTypeFilter').addEventListener('change', updateEntityView);
        document.getElementById('entityPhraseFilter').addEventListener('change', updateEntityView);
        document.getElementById('useDeduplicatedToggle').addEventListener('change', function(e) {
            useDeduplicated = e.target.checked;
            if (deduplicatedData.length > 0) {
                allData = useDeduplicated ? deduplicatedData : rawData;
                filteredData = [...allData];
                updateStats();
                updatePhraseStats();
                updateEntityView();
                renderTable();
            }
        });

        document.querySelectorAll('.sortable').forEach(th => {
            th.addEventListener('click', () => sortData(th.dataset.sort));
        });

        // Load studies data from CSV
        async function loadStudiesData() {
            try {
                const response = await fetch('lib/flow.csv');
                if (!response.ok) {
                    throw new Error(`Failed to load CSV: ${response.status} ${response.statusText}`);
                }
                const csvText = await response.text();
                
                // Parse CSV - handle multi-line quoted fields
                const allLines = csvText.split(/\r?\n/);
                const lines = [];
                let currentLine = '';
                let inQuotes = false;
                
                for (let i = 0; i < allLines.length; i++) {
                    const line = allLines[i];
                    currentLine += (currentLine ? '\n' : '') + line;
                    
                    // Count quotes to determine if we're still in a quoted field
                    const quoteCount = (currentLine.match(/"/g) || []).length;
                    inQuotes = quoteCount % 2 !== 0;
                    
                    // If not in quotes, this is a complete line
                    if (!inQuotes) {
                        if (currentLine.trim()) {
                            lines.push(currentLine);
                        }
                        currentLine = '';
                    }
                }
                
                // Add last line if any
                if (currentLine.trim()) {
                    lines.push(currentLine);
                }
                
                if (lines.length < 2) {
                    document.getElementById('studiesStatsGrid').innerHTML = 
                        '<div class="studies-empty-state">No data found in CSV file</div>';
                    return;
                }
                
                // Parse header using parseCSVLine to handle quoted fields
                const headerRow = parseCSVLine(lines[0]);
                const headers = headerRow.map(h => h.trim());
                const data = [];
                
                // Find column indices
                const convIdIdx = headers.indexOf('conversationId');
                const contractIdIdx = headers.indexOf('contractId');
                const clientIdIdx = headers.indexOf('clientId');
                const clientNameIdx = headers.indexOf('clientName');
                const isProServicesIdx = headers.indexOf('is_pro_services_related');
                const chatStartIdx = headers.indexOf('chatStartDateTime');
                
                // Find all matched_phrases columns
                const phraseColumns = [];
                for (let i = 0; i < headers.length; i++) {
                    if (headers[i].startsWith('matched_phrases/')) {
                        phraseColumns.push(i);
                    }
                }
                
                // Parse data rows
                for (let i = 1; i < lines.length; i++) {
                    const row = parseCSVLine(lines[i]);
                    if (row.length < headers.length) continue;
                    
                    // Check if is_pro_services_related is TRUE
                    const isProServices = row[isProServicesIdx]?.toUpperCase().trim() === 'TRUE';
                    if (!isProServices) continue;
                    
                    // Extract phrases
                    const phrases = [];
                    phraseColumns.forEach(colIdx => {
                        const phrase = row[colIdx]?.trim();
                        if (phrase && phrase.length > 0) {
                            phrases.push(phrase);
                        }
                    });
                    
                    if (phrases.length === 0) continue;
                    
                    data.push({
                        conversationId: (row[convIdIdx] || '').trim(),
                        contractId: (row[contractIdIdx] || '').trim(),
                        clientId: (row[clientIdIdx] || '').trim(),
                        clientName: (row[clientNameIdx] || '').trim(),
                        chatStartDateTime: (row[chatStartIdx] || '').trim(),
                        phrases: phrases
                    });
                }
                
                // Group by contractId + conversationId combination
                // This ensures each unique chat (contract + conversation) is shown separately
                const chatsByKey = new Map();
                
                data.forEach(item => {
                    // Create a unique key: contractId_conversationId or just conversationId if no contractId
                    const key = item.contractId 
                        ? `${item.contractId}_${item.conversationId}`
                        : item.conversationId;
                    
                    if (!chatsByKey.has(key)) {
                        chatsByKey.set(key, {
                            contractId: item.contractId,
                            conversationId: item.conversationId,
                            clientId: item.clientId,
                            clientName: item.clientName,
                            chatStartDateTime: item.chatStartDateTime,
                            phrases: []
                        });
                    }
                    
                    const chat = chatsByKey.get(key);
                    // Merge phrases, avoiding duplicates
                    item.phrases.forEach(phrase => {
                        if (!chat.phrases.includes(phrase)) {
                            chat.phrases.push(phrase);
                        }
                    });
                });
                
                // Convert to array and sort
                const chats = Array.from(chatsByKey.values());
                chats.sort((a, b) => {
                    // Sort by contractId first, then by conversationId
                    if (a.contractId && b.contractId) {
                        const contractCompare = a.contractId.localeCompare(b.contractId);
                        if (contractCompare !== 0) return contractCompare;
                        return a.conversationId.localeCompare(b.conversationId);
                    } else if (a.contractId) {
                        return -1;
                    } else if (b.contractId) {
                        return 1;
                    } else {
                        return a.conversationId.localeCompare(b.conversationId);
                    }
                });
                
                // Update stats
                const totalProServices = data.length;
                const totalChats = chats.length;
                const totalPhrases = chats.reduce((sum, chat) => sum + chat.phrases.length, 0);
                
                document.getElementById('studiesStatsGrid').innerHTML = `
                    <div class="studies-stat-card">
                        <div class="studies-stat-value">${totalProServices.toLocaleString()}</div>
                        <div class="studies-stat-label">Total Pro Services Related (TRUE)</div>
                    </div>
                    <div class="studies-stat-card">
                        <div class="studies-stat-value">${totalChats.toLocaleString()}</div>
                        <div class="studies-stat-label">Unique Chats</div>
                    </div>
                    <div class="studies-stat-card">
                        <div class="studies-stat-value">${totalPhrases.toLocaleString()}</div>
                        <div class="studies-stat-label">Total Phrases</div>
                    </div>
                `;
                
                // Render chats
                const chatsContainer = document.getElementById('studiesChatsContainer');
                if (chats.length === 0) {
                    chatsContainer.innerHTML = `
                        <div class="studies-empty-state">
                            <div>No chats found with pro services related = TRUE</div>
                        </div>
                    `;
                    return;
                }
                
                let html = '';
                chats.forEach(chat => {
                    // Display both contract ID and conversation ID as requested
                    const chatNameParts = [];
                    if (chat.contractId) {
                        chatNameParts.push(`Contract ${escapeHtml(chat.contractId)}`);
                    }
                    if (chat.conversationId) {
                        chatNameParts.push(`Chat ${escapeHtml(chat.conversationId)}`);
                    }
                    const chatName = chatNameParts.length > 0 
                        ? chatNameParts.join(' ‚Ä¢ ')
                        : 'Unknown Chat';
                    
                    html += `
                        <div class="studies-chat-container">
                            <div class="studies-chat-header">
                                <div>
                                    <div class="studies-chat-title">${chatName}</div>
                                </div>
                                <div class="studies-chat-meta">
                                    ${chat.clientName ? `<span>Client: ${escapeHtml(chat.clientName)}</span>` : ''}
                                    ${chat.clientId ? `<span>Client ID: ${escapeHtml(chat.clientId)}</span>` : ''}
                                    ${chat.chatStartDateTime ? `<span>Date: ${escapeHtml(chat.chatStartDateTime)}</span>` : ''}
                                    <span>Phrases: ${chat.phrases.length}</span>
                                </div>
                            </div>
                            <div class="studies-chat-content">
                                ${chat.phrases.map(phrase => `
                                    <div class="studies-chat-message">
                                        <div class="studies-chat-message-text">${escapeHtml(phrase)}</div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                });
                
                chatsContainer.innerHTML = html;
                
            } catch (error) {
                console.error('Error loading studies data:', error);
                document.getElementById('studiesStatsGrid').innerHTML = 
                    '<div class="studies-empty-state">Error loading CSV file. Please ensure flow.csv exists at /Users/saharsabbagh/Downloads/flow.csv</div>';
                document.getElementById('studiesChatsContainer').innerHTML = '';
            }
        }
        
        // Helper function to parse CSV line (handles quoted fields)
        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        // Escaped quote
                        current += '"';
                        i++;
                    } else {
                        // Toggle quote state
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    // End of field
                    result.push(current);
                    current = '';
                } else {
                    current += char;
                }
            }
            
            // Add last field
            result.push(current);
            return result;
        }

        // Load data on page load
        loadData();
        loadStudiesData();
    </script>
</body>
</html>
